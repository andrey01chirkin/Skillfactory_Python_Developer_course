<!DOCTYPE html>
<!-- saved from url=(0213)https://lms.skillfactory.ru/xblock/block-v1:SkillFactory+PDEV2.0+JUL_2024+type@vertical+block@d54311b5d6984cb1854d71646a702ba4?show_title=0&show_bookmark_button=0&recheck_access=1&view=student_view&format=Homework -->
<html lang="ru"><!--<![endif]--><head dir="ltr"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="origin-trial" content="ArNBN7d1AkvMhJTGWXlJ8td/AN4lOokzOnqKRNkTnLqaqx0HpfYvmx8JePPs/emKh6O5fckx14LeZIGJ1AQYjgAAAABzeyJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjE4MDAwIiwiZmVhdHVyZSI6IkRpc2FibGVEaWZmZXJlbnRPcmlnaW5TdWJmcmFtZURpYWxvZ1N1cHByZXNzaW9uIiwiZXhwaXJ5IjoxNjM5NTI2Mzk5fQ==">


    
    <title>

 PDEV2.0 Courseware | Skillfactory
</title>




<script async="" src="./tag.js"></script><script type="text/javascript" src="./djangojs.0387ac39f9bc.js"></script>
<script type="text/javascript" src="./ie11_find_array.bd1c6dc7a133.js"></script>

<link rel="icon" type="image/x-icon" href="https://lms-cdn.skillfactory.ru/static/edx-theme/images/favicon.92d1a59c6dad.ico">




  

    <link href="./lms-style-vendor.68e48093f5dd.css" rel="stylesheet" type="text/css">




  

    <link href="./lms-main-v1.0c15fb93e2a0.css" rel="stylesheet" type="text/css">





    
<script type="text/javascript" src="./lms-main_vendor.3c3c9a2604d6.js" charset="utf-8"></script>



    
<script type="text/javascript" src="./lms-application.98d9a8549a03.js" charset="utf-8"></script>




    
    
    <script type="text/javascript" src="./commons.9ce1adffa211f712ab2b.84b81fb94f7e.js"></script>



<script>
    window.baseUrl = "https://lms\u002Dcdn.skillfactory.ru/static/";
    (function (require) {
        require.config({
            baseUrl: window.baseUrl
        });
    }).call(this, require || RequireJS.require);
</script>
<script type="text/javascript" src="./require-config.3cb9f35ae96d.js"></script>

<script type="text/javascript">
        (function (require) {
          require.config({
              paths: {
                'course_bookmarks/js/views/bookmark_button': 'course_bookmarks/js/views/bookmark_button.d4cfaf3361fa',
'js/views/message_banner': 'js/views/message_banner.141974fd4f5d',
'moment': 'common/js/vendor/moment-with-locales.e3cc27d412a1',
'moment-timezone': 'common/js/vendor/moment-timezone-with-data.60142e6c4416',
'js/courseware/course_info_events': 'js/courseware/course_info_events.2fc35b57627f',
'js/courseware/accordion_events': 'js/courseware/accordion_events.6064c7809de5',
'js/dateutil_factory': 'js/dateutil_factory.a28baef97506',
'js/courseware/link_clicked_events': 'js/courseware/link_clicked_events',
'js/courseware/toggle_element_visibility': 'js/courseware/toggle_element_visibility.474ff5ba9de3',
'js/student_account/logistration_factory': 'js/student_account/logistration_factory.5e55252d0ace',
'js/courseware/courseware_factory': 'js/courseware/courseware_factory.1504fc10caef',
'js/groups/views/cohorts_dashboard_factory': 'js/groups/views/cohorts_dashboard_factory.ca68388d81d6',
'js/groups/discussions_management/discussions_dashboard_factory': 'js/discussions_management/views/discussions_dashboard_factory.2e10d9097343',
'draggabilly': 'js/vendor/draggabilly.26caba6f7187',
'hls': 'common/js/vendor/hls.5e0c7e1b3bfd'
            }
          });
        }).call(this, require || RequireJS.require);
    </script>




  

    <link href="./lms-style-course-vendor.cc467ea1c47d.css" rel="stylesheet" type="text/css">




  

    <link href="./lms-course.e8431918ed94.css" rel="stylesheet" type="text/css">




<script type="text/javascript" src="./jquery.autocomplete.964a0bfb4fd2.js" async=""></script>
<script type="text/javascript" src="./tooltip_manager.b8fa94d4cefc.js" async=""></script>

<link href="./jquery.autocomplete.css" rel="preload" type="text/css">
  

  <!--<base target="_parent">--><base href="." target="_parent">

<script type="text/javascript">
  var $$course_id = "course\u002Dv1:SkillFactory+PDEV2.0+JUL_2024";
</script>










<script type="application/json" id="user-metadata">
    null
</script>









<!-- dummy Segment -->
<script type="text/javascript">
  var analytics = {
    track: function() { return; },
    trackLink: function() { return; },
    pageview: function() { return; },
    page: function() { return; }
  };
</script>
<!-- end dummy Segment -->


<meta name="path_prefix" content="">


<meta name="openedx-release-line" content="maple">






<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(91593102, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
    });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/91593102" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<!-- Google tag (gtag.js) -->
<script async="" src="./js"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-T4T8K8RLJL');
</script>

<script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="https://lms-cdn.skillfactory.ru/static/js/dateutil_factory.a28baef97506.js?raw" src="./dateutil_factory.a28baef97506.js"></script><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover, .MJXp-munder {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > *, .MJXp-munder > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>

<body class="ltr view-in-course view-courseware courseware  lang_ru view-in-mfe"><div id="MathJax_Message" style="display: none;"></div>


<div id="page-prompt"></div>
    
    <a class="nav-skip sr-only sr-only-focusable" href="https://lms.skillfactory.ru/xblock/block-v1:SkillFactory+PDEV2.0+JUL_2024+type@vertical+block@d54311b5d6984cb1854d71646a702ba4?show_title=0&amp;show_bookmark_button=0&amp;recheck_access=1&amp;view=student_view&amp;format=Homework#main">Перейти к основному содержимому</a>


    










    <div class="marketing-hero"></div>

<div class="content-wrapper main-container" id="content" dir="ltr">
    








<script type="text/template" id="image-modal-tpl">
    <div class="wrapper-modal wrapper-modal-image">
  <section class="image-link">
    <%= smallHTML%> <% // xss-lint: disable=underscore-not-escaped %>
    <a href="#" class="modal-ui-icon action-fullscreen" role="button">
      <span class="label">
        <span class="icon fa fa-arrows-alt fa-large" aria-hidden="true"></span> <%- gettext("Fullscreen") %>
      </span>
    </a>
  </section>

  <section class="image-modal">
    <section class="image-content">
      <div class="image-wrapper">
        <img alt="<%- largeALT %>, <%- gettext('Large') %>" src="<%- largeSRC %>" />
      </div>

      <a href="#" class="modal-ui-icon action-close" role="button">
        <span class="label">
          <span class="icon fa fa-remove fa-large" aria-hidden="true"></span> <%- gettext("Close") %>
        </span>
      </a>

      <ul class="image-controls">
        <li class="image-control">
          <a href="#" class="modal-ui-icon action-zoom-in" role="button">
            <span class="label">
              <span class="icon fa fa fa-search-plus fa-large" aria-hidden="true"></span> <%- gettext("Zoom In") %>
            </span>
          </a>
        </li>

        <li class="image-control">
          <a href="#" class="modal-ui-icon action-zoom-out is-disabled" aria-disabled="true" role="button">
            <span class="label">
              <span class="icon fa fa fa-search-minus fa-large" aria-hidden="true"></span> <%- gettext("Zoom Out") %>
            </span>
          </a>
        </li>
      </ul>
    </section>
  </section>
</div>

</script>







<div class="course-wrapper chromeless">
  <section class="course-content" id="course-content" data-enable-completion-on-view-service="false" style="display: block; width: auto; margin: 0;">
      <main id="main" aria-label="Content">
        
<div class="xblock xblock-student_view xblock-student_view-vertical xblock-initialized" data-course-id="course-v1:SkillFactory+PDEV2.0+JUL_2024" data-init="VerticalStudentView" data-runtime-class="LmsRuntime" data-runtime-version="1" data-block-type="vertical" data-usage-id="block-v1:SkillFactory+PDEV2.0+JUL_2024+type@vertical+block@d54311b5d6984cb1854d71646a702ba4" data-request-token="11f167548ea811ef93744a31bd8e8444" data-graded="True" data-has-score="False">
  









<div class="vert-mod">
    <div class="vert vert-0" data-id="block-v1:SkillFactory+PDEV2.0+JUL_2024+type@html+block@f19ad49bf3184c80bb20286e32f3bb1f">
        
<div class="xblock xblock-student_view xblock-student_view-html xmodule_display xmodule_HtmlBlock xblock-initialized" data-course-id="course-v1:SkillFactory+PDEV2.0+JUL_2024" data-init="XBlockToXModuleShim" data-runtime-class="LmsRuntime" data-runtime-version="1" data-block-type="html" data-usage-id="block-v1:SkillFactory+PDEV2.0+JUL_2024+type@html+block@f19ad49bf3184c80bb20286e32f3bb1f" data-request-token="11f167548ea811ef93744a31bd8e8444" data-graded="True" data-has-score="False">
  
  <div class="hidden-block">
  <link rel="preconnect" href="https://fonts.googleapis.com/">
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="">
<link href="./css2" rel="stylesheet">
  
  <style>
 
 @font-face {
  font-family: 'Mont';
  src: url('//lms-cdn.skillfactory.ru/assets/courseware/v1/abb74a597efa488c9c0e5da1cf8f8570/asset-v1:SkillFactory+PDEV2.0+JUL_2024+type@asset+block/Mont-Regular.ttf') format('truetype');
  font-weight: 600;
  font-style: normal;
}

@font-face {
  font-family: 'Mont';
  src: url('//lms-cdn.skillfactory.ru/assets/courseware/v1/5cf16df9fb7a9a4aafd56cb48be75cf2/asset-v1:SkillFactory+PDEV2.0+JUL_2024+type@asset+block/Mont-SemiBold.ttf') format('truetype');
  font-weight: 700;
  font-style: bold;
}
    
.course-wrapper .course-content .vert-mod .vert, .course-wrapper .courseware-results-wrapper .vert-mod .vert {
    border-bottom: none!important;
    margin-bottom: 0!important;
    padding: 0!important;
}
    
.wrapper-problem-response, .problem, .field label, .problem p, .problem strong {
  font-family: 'Mont', Arial, sans-serif !important;
  font-style: normal !important;
  font-weight: 600 !important;
  box-sizing: border-box!important;
  font-size: 18px!important;
}
.problem strong, .field strong {
  font-weight: 700 !important;
}
  
  
.problems-wrapper  {
  max-width:800px!important;
  margin:auto!important;
}
  
.btn-brand {
   	font-family: 'Mont', Arial, sans-serif !important;
  	font-style: normal!important;
	font-weight: 700!important;
	font-size: 15px!important;
	line-height: 20px!important;
   	padding: 20px 24px!important;
   	border-color: #181818!important;
   	background: #181818!important;
   	color: #FEFEFE!important;
   	border-radius: 5px!important;
 }

.btn-brand:disabled{
   border-color: #E8E8EA!important;
   background: #E8E8EA!important;
   color: #CAC8CC!important;
}    


.hidden-block {
  display: none;
}

.main-block {
  font-family: 'Mont', Arial, sans-serif !important;
  font-style: normal !important;
  font-weight: 600 !important;
  box-sizing: border-box!important;
  font-size: 18px!important;
  line-height: 28px!important;
  max-width: 864px;
  margin: auto auto;
  word-break: break-word;
}
    
 .main-block pre {
    padding:18px 18px 18px 18px!important;
    border-radius:8px!important;
      font-family: 'PT Mono', monospace!important;
  font-style: normal !important;
  font-weight: 400 !important;
   background-color:#F4F3F5!important;
  }   
    
.main-block code {
   font-family: 'PT Mono', monospace!important;
  font-style: normal !important;
  font-weight: 400 !important;
  box-sizing: border-box!important;
  font-size: 18px!important;
  line-height: 28px!important;
  background-color: #F9F8FA !important;
  border-radius:3px!important;
    padding: 4px!important;
  display:inline-block;
}   
  
 .main-block .mjx-svg-math svg:not(:root) {
   overflow-x:scroll!important;
 }
   
  
.main-block > p, .list, .ordered-list, .h1, .h2, .h3, .two-col, .accordion, .panel, .overflow-table, .num-list {
  max-width: 800px;
  margin-left:auto!important;
  margin-right:auto!important;
  box-sizing: border-box!important;
 
}
  
.main-block .MathJax_SVG_Display {
  max-width:800px;
      letter-spacing: normal;
    word-spacing: normal;
    word-wrap: normal;
}
  
.main-block .list {  
 padding-left: 0!important;
}
  
.main-block .list > li {
  display: block;
  position: relative;
  padding-left: 22px;
}


.main-block .list > li::before {
  content: "";
  display: inline-block;
  position: absolute;
  top: 8px;
  left: 0px;
  background: url("data:image/svg+xml,%3Csvg width='7' height='8' viewBox='0 0 7 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M6.39131 2.90604C7.2029 3.39224 7.2029 4.60776 6.3913 5.09397L1.82609 7.82888C1.01449 8.31509 -4.0964e-08 7.70733 0 6.73491L2.30422e-07 1.26508C2.71386e-07 0.292671 1.01449 -0.315085 1.82609 0.171122L6.39131 2.90604Z' fill='%23181818'/%3E%3C/svg%3E");
  background-size: 8px 8px;
  width: 8px;
  height: 8px;
}

.block-800 {
  max-width: 800px !important;
  margin-left: auto;
  margin-right: auto;
}

 .partner-banner {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  background: url("https://lms.skillfactory.ru/asset-v1:SkillFactory+FPW-2.0+27AUG2020+type@asset+block@Vector_103.svg") no-repeat;
  background-size: 260px 230px;
  background-position: top 39px right 30px;
  padding: 40px 30px 43px 32px;
  background-color: #EFEFFE;
  border-radius: 8px;
  margin: auto auto 50px auto;
}


.partner-banner .desc {
  max-width: 455px;
  z-index: 1;
}

.partner-banner .desc-text {

  font-weight: 600 !important;
  font-size: 15px !important;
  line-height: 22px !important;


}

.partner-banner .logo {
  margin-top: 6px;
  display: flex;
  flex-shrink: 0;
  justify-content: center;
  align-items: center;
  z-index: 2;
  width: 123px;
  height: 123px;
  border-radius: 100%;
  /* SkillFactory/grayscale/white */
  background-color: #FEFEFE !important;
}

 .partner-banner .h3 {
  line-height: 30px !important;
  margin-top: 0 !important;
  margin-bottom: 16px !important;
}

@media screen and (max-width: 480px) {
   .partner-banner {
    flex-direction: column;
    background: url("https://lms.skillfactory.ru/asset-v1:Skillfactory+AD+2020+type@asset+block@Vector_mob.svg") no-repeat;
    background-size: 348px 88px;
    background-position: bottom 35px right 0px;
    padding: 20px;
    background-color: #EFEFFE;
    border-radius: 8px;
    margin: auto auto 50px auto;
  }

  .partner-banner .logo {
    align-self: flex-end;
  }
}

.main-block p {
  color: #181818 !important;
  margin-bottom: 32px!important;
  font-family: 'Mont', Arial, sans-serif !important;
  font-style: normal !important;
  font-weight: 600 !important;
  font-size: 18px !important;
  line-height: 28px !important;

}

.main-block a {
  text-decoration: none !important;
  color: #6AC207 !important;
}

.main-block li {
  margin-bottom: 16px !important;
}

.main-block strong {
  font-weight: 700 !important;
}


.main-block .h1 {
  font-weight: 700 !important;
  font-size: 40px !important;
  line-height: 42px !important;
  color: #181818 !important;
  margin-bottom: 24px;
}

.main-block .h2 {
  font-weight: 700 !important;
  font-size: 36px !important;
  line-height: 40px !important;
  color: #181818 !important;
  margin-bottom: 16px;
  margin-top: 50px;
}

.main-block .h2:first-child {
  margin-top: 0px;
}

.main-block .h3 {
  /* 28 Semib */
  font-weight: 700 !important;
  font-size: 28px !important;
  line-height: 30px !important;
  /* SkillFactory/grayscale/coal */
  color: #181818;
  margin-bottom: 12px !important;
  margin-top: 50px;
}

.main-block .h3:first-child {
  margin-top: 0px;
}

.two-col {
  display:flex;
  align-items:start;
  gap:32px;
  flex-wrap:wrap;
  max-width:800px;
}
.col {
  flex-basis: 300px;
  flex-grow:1;
}
  
.col p {
  margin-bottom:12px!important;
}

.main-block .grey-text {
  color: #7B7A7D !important;
  font-size: 15px !important;
}


.main-block .overflow-table {
  overflow-x: auto !important;
  max-width: 800px;
}

.main-block .overflow-table table {
  border-collapse: separate !important;
  border-spacing: 0 !important;
  overflow-x: auto !important;
}

.main-block th {
  color: #7B7A7D !important;
  font-weight: 700 !important;
  font-size: 15px !important;
  line-height: 22px !important;
  text-align: left !important;
  vertical-align: top !important;
  padding: 20px 22px 24px 22px !important;
  white-space: nowrap !important;
  background-color: #FEFEFE !important;
  border: none !important;
}

.main-block td {
  font-weight: 600 !important;
  font-size: 15px !important;
  line-height: 22px !important;
  /* SkillFactory/grayscale/coal */
  color: #181818 !important;
  vertical-align: center !important;
  text-align: left !important;
  padding: 20px 22px 24px 22px !important;
  border: 1px white !important;
  border-style: solid none solid none !important;

}

.main-block tr:nth-child(even) {
  background-color: #F9F8FA !important;
}

.main-block tr:nth-child(even) td:first-child {
  border-top-left-radius: 10px !important;
  border-bottom-left-radius: 10px !important;
}

.main-block tr:nth-child(even) td:last-child {
  border-top-right-radius: 10px !important;
  border-bottom-right-radius: 10px !important;
}
  
.quote {
   max-width: 864px !important;
  background-color: #F4F3F5;
  border-radius: 8px;
  box-sizing: border-box;
  padding: 40px 43px;
  margin: 50px 0;
}

.quote-source svg {
  fill: #181818;
  stroke: #FEFEFE;
  transition: fill ease-in-out .3s;
}

.quote .quote-text {
  font-style: normal;
  font-weight: 600;
  font-size: 18px;
  line-height: 156%;
}

.quote .quote-footer {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: flex-end;

}


.quote .quote-author {
  display: flex;
  margin-top: 32px;
  font-size: 15px;
  line-height: 22px;
}

.quote .quote-author img {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  margin-right: 18px;
}

.quote-source {
  display: flex;
  flex-direction: row;
  align-items: center;
  padding: 0px;
  gap: 12px;
  font-size: 15px;
  font-weight: bold;
}

.quote-source a {
  color: #181818 !important;
  transition: color ease-in-out .3s;
}

.quote-source:hover a {
  color: #6AC207 !important;
}

.quote-source:hover svg {
  fill: #6AC207 !important;
}

@media screen and (max-width: 480px) {
  .quote .quote-footer {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

.quote-source {
    display: flex;
    flex-direction: row;
    align-items: center;
    padding-left: 66px;
    gap: 12px;
    font-size: 15px;
    font-weight: bold;
  }
}
    
.img {
  margin:10px auto 20px auto;
  max-width:800px;
  text-align:center!important;
}
  .img p {
    text-align:center!important;
  }
  
  .img > img {
     border-radius:8px;
  }
    


 .color-container {
  max-width: 864px !important;
  padding: 40px 32px;
  max-width: 864px;
  border-radius: 8px;
  font-weight: 600;
  font-size: 18px;
  line-height: 28px;
  margin: 50px 0;
}

.container-flex {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  gap: 24px;
}


@media screen and (max-width: 480px) {
  .container-flex {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 24px;

  }
}

.orange-container {
  background: #FFF0EC;
}

.blue-container {
  background: #EFEFFE;
}


.container-icon {
  display: flex;
  flex: 0 0 40px;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 50%;
}

.orange-container .container-icon {
  background: #FF6945;
}

.blue-container .container-icon {
  background: #1814F5;
}


.term {
  border-left: 4px solid #B5E916;
  padding-left: 24px;
  margin-bottom: 50px;
   max-width:800px;
   margin: 50px auto;
   box-sizing: border-box!important;
}


.sf-button {
  position: relative;
  display:block;
  padding: 20px 24px 20px 24px;
  color: #181818!important;
  background-color: #fefefe;
  border: 1px solid #e8e8ea;
  border-radius: 5px;
  cursor: pointer;
  width: fit-content !important;
  font-family: 'Mont'!important;
  font-style: normal;
  font-weight: 700!important;
  font-size: 15px!important;
  line-height: 20px!important;
  margin-top: 24px;
  margin-bottom: 50px;

}
  a .button-label {
    color: #181818!important;
  }
  
.sf-button--icon-start {
  padding: 20px 24px 20px 22px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
}

.sf-button:hover {
  background-color: #f4f3f5;
}

 .module-author {
  max-width: 864px !important;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: flex-start;
  padding: 40px 32px;
  gap: 30px;
  background: #F4F3F5;
  border-radius: 8px;
  box-sizing: border-box;
}


.module-author img {
  width: 211px;
  height: 211px;
  border-radius: 50%;
}

.module-author-descr-head {
  color: #7B7A7D;
  margin-bottom: 30px;
}

.module-author-descr-name {
  font-weight: 700;
  font-size: 28px;
  line-height: 30px;
  letter-spacing: -0.01em;
  margin-bottom: 8px;
}

.module-author-descr-works ul {
  font-style: normal;
  font-weight: 600;
  font-size: 18px;
  line-height: 28px;
}

.module-author-descr-works ul li {
  margin: 0 0 16px 0;
}

@media screen and (max-width: 480px) {
   .module-author {
    display: flex;
    flex-direction: column-reverse;
    align-items: flex-start;

  }

   .module-author img {
    width: 110px;
    height: 110px;
    border-radius: 50%;

  }
}


.block-example {
  padding: 40px 32px;
  max-width: 864px !important;
  background: rgba(181, 233, 22, 0.2);
  border-radius: 8px;
  margin: 50px 0;
}

.block-example .example-title {
  font-weight: 700;
  font-size: 22px;
  line-height: 26px;
  letter-spacing: -0.01em;
  margin-bottom: 16px;
}
    
 #more {
   display: none;
   max-width:800px;
   margin-inline:auto;
   transition: .25s ease;
 }    

details summary {
  padding: 28px 24px;
  background-color: #F4F3F5;
  border-radius: 5px;
  transition: 0.4s;
  font-family: 'Mont', Arial, sans-serif !important;
  font-style: normal !important;
  font-weight: 700 !important;
  box-sizing: border-box;
  font-size: 18px;
  line-height: 28px;
  cursor: pointer;
  margin: 32px auto 32px auto;
  max-width:800px;
}


details summary::after {
  width: 16px;
  height: 16px;
  margin-top: 6px;
  float: right;
  content: "";
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16' fill='none'%3E%3Cpath d='M2.39844 5L7.99844 10.6L13.5984 5' stroke='%23181818' stroke-width='2'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-size: 16px;
  background-position: center;
  transform: rotate(0deg);
  transition: transform 0.2s ease-in-out;
}
  
/* Убираем стандартный маркер Chrome */
details summary::-webkit-details-marker {
  display: none!important;
}
/* Убираем стандартный маркер Firefox */
details > summary {
  list-style: none!important;
}
  
details[open] {
  margin-bottom:0;
}

details[open] > summary::after {
  transform: rotate(180deg);
}

.panel {
  padding: 0 20px;
}

.panel p:first-child {
  margin-top: 24px!important;
}
  
.noselect {
  -webkit-touch-callout: none;
  /* iOS Safari */
  -webkit-user-select: none;
  /* Safari */
  -khtml-user-select: none;
  /* Konqueror HTML */
  -moz-user-select: none;
  /* Old versions of Firefox */
  -ms-user-select: none;
  /* Internet Explorer/Edge */
  user-select: none;
  /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}
.factory-mb-50 {
  margin-bottom: 50px!important;
}
  
  </style>
   <script defer="" type="text/javascript">
function openMore() {
  var dots = document.getElementById("dots");
  var moreText = document.getElementById("more");
  var btnText = document.getElementById("myBtn");

  if (dots.style.display === "none") {
    dots.style.display = "inline";
    btnText.innerHTML = "Показать больше"; 
    moreText.style.display = "none";
  } else {
    dots.style.display = "none";
    btnText.innerHTML = "Скрыть"; 
    moreText.style.display = "inline";
  }
}</script>
 
  </div>


</div>

    </div>
    <div class="vert vert-1" data-id="block-v1:SkillFactory+PDEV2.0+JUL_2024+type@html+block@617564a35c8c405ca58c1875c9e808ee">
        
<div class="xblock xblock-student_view xblock-student_view-html xmodule_display xmodule_HtmlBlock xblock-initialized" data-course-id="course-v1:SkillFactory+PDEV2.0+JUL_2024" data-init="XBlockToXModuleShim" data-runtime-class="LmsRuntime" data-runtime-version="1" data-block-type="html" data-usage-id="block-v1:SkillFactory+PDEV2.0+JUL_2024+type@html+block@617564a35c8c405ca58c1875c9e808ee" data-request-token="11f167548ea811ef93744a31bd8e8444" data-graded="True" data-has-score="False">
  
  <div class="main-block">
<p>В предыдущем юните мы познакомились с линейными структурами данных, такими как списки, стеки и очереди. Эти структуры организуют данные в последовательном порядке, что удобно для решения многих задач. Однако, существуют задачи, в которых линейные структуры данных неэффективны. Например, представить сеть дорог, которые связывают города между собой различными путями или представить иерархическую структуру организации, где сотрудники подчиняются друг другу.</p>
<p>Для решения таких задач используются <strong>нелинейные структуры</strong> данных, которые позволяют организовывать данные более сложным образом. В этом юните вы познакомитесь с двумя важными нелинейными структурами данных — <strong>Деревья</strong> и <strong>Графы</strong>.</p>
<p></p>
<p><strong>Также в этом юните вы:</strong></p>
<ul class="list">
<li>Изучите базовые принципы и терминологию графов и деревьев, включая узлы, ребра, пути, циклы, корни, листья.</li>
<li>Научитесь реализовывать базовые алгоритмы на графах и деревьях, такие как поиск в глубину и поиск в ширину.</li>
<li>Познакомитесь со способами представления графов и деревьев в коде.</li>
</ul>
<p></p>
<div class="h3">Деревья</div>
<p></p>
<div class="term"><strong>Дерево</strong> — это нелинейная структура данных, которая представляет собой иерархическую организацию данных. Дерево состоит из узлов, и каждый узел может иметь несколько дочерних узлов.</div>
<p style="display: flex; justify-content: center;"><img src="./asset-v1_SkillFactory+QAP-3.0+2021+type@asset+block@module_22.09.png" alt=""></p>
<p style="display: flex; justify-content: center;" class="grey-text"><span><a href="https://pythonspot.com/wp-content/uploads/2015/09/tree.jpg" target="_blank" rel="noopener">Источник</a></span></p>
<p>Для работы с Деревьями необходимо в первую очередь разобраться в терминологии. Сейчас вы можете просто познакомиться с каждым из терминов, а дальше у вас будет возможность поподробнее погрузиться в каждый из них:</p>
<div class="term">
<ul class="list">
<li><strong>Узел (Node) </strong>— это элемент дерева, содержащий данные.</li>
<li><strong>Корень (Root)</strong> — это узел, не имеющий родительского узла.</li>
<li><strong>Лист (Leaf)</strong> — узел, не имеющий дочерних узлов.</li>
<li><strong>Родительский узел (Parent Node)</strong> — тип узла, который имеет дочерние узлы.</li>
<li><strong>Дочерний узел (Child Node)</strong> — тип узла, который имеет родительский узел.</li>
<li><strong>Ветвь (Branch) </strong>— путь от корня до листа.</li>
<li><strong>Глубина (Depth)</strong> — количество узлов на пути от корня до узла.</li>
<li><strong>Высота (Height) </strong>— максимальная глубина дерева.</li>
</ul>
</div>
<p>Перед тем как перейти к применению этих элементов на практике, надо уточнить, что Деревья бывают разных видов. Самый общий случай — это N-арное дерево (N-ary Tree), в котором каждый узел может иметь любое количество дочерних узлов.</p>
<p>Крайне популярным видом является бинарное дерево (Binary Tree), в нем каждый узел может иметь не более двух дочерних узлов. Также частый случай — модификации различных видов, как например бинарное дерево поиска (Binary Search Tree), в нем не просто каждый узел не может иметь больше двух дочерних узлов, но еще и должно выполняться правильно, что значения в левом поддереве узла, всегда меньше значения текущего узла, а в правом — больше.</p>
<p>Давайте начнем с рассмотрения N-арного дерева и реализации его в Python. Первый термин, который следует изучить, — это Узел (Node):</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:
   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):
       self.value = value
       self.children = []

   <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_child</span>(<span class="hljs-params">self, child</span>):
       self.children.append(child)</pre>
<p>Итак, наш класс — это представление узла. Конструктор принимает значение, которое будет хранить в атрибуте <code>value</code>, а также создает атрибут <code>children</code> — пустой список, в который вы будете помещать новые узлы.</p>
<p>Следующий термин — это Корень (Root). Вы уже можете его создать, потому что, как вы уже догадались, корнем дерева будет являться его самый первый узел:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">root = TreeNode(<span class="hljs-number">1</span>)</pre>
<p>Пока Дерево выглядит так:</p>
<p style="display: flex; justify-content: center;"><img src="./asset-v1_SkillFactory+QAP-3.0+2021+type@asset+block@module_22.10.png" alt=""></p>
<p>Переходим к следующим понятиям — Лист (Leaf) и Родительский узел (Parent Node).</p>
<p>Как только вы добавили новый узел в Дерево, внесите его в список <code>children </code>для нашего <code>root </code>и создайте новый лист, а <code>root </code>станет родительским узлом:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">root = TreeNode(<span class="hljs-number">1</span>)
child1 = TreeNode(<span class="hljs-number">2</span>)
root.add_child(child1)</pre>
<p style="display: flex; justify-content: center;"><img src="./asset-v1_SkillFactory+QAP-3.0+2021+type@asset+block@module_22.11.png" alt=""></p>
<p>При этом новый узел <code>child1 </code>со значением 2 является Дочерним узлом (Child Node).</p>
<p>Для разбора оставшихся терминов нужно усложнить Дерево:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">root = TreeNode(<span class="hljs-number">1</span>)
child1 = TreeNode(<span class="hljs-number">2</span>)
root.add_child(child1)

child2 = TreeNode(<span class="hljs-number">3</span>)
root.add_child(child2)

child3 = TreeNode(<span class="hljs-number">4</span>)
root.add_child(child3)

child4 = TreeNode(<span class="hljs-number">5</span>)
child1.add_child(child4)</pre>
<p style="display: flex; justify-content: center;"><img src="./asset-v1_SkillFactory+QAP-3.0+2021+type@asset+block@module_22.12.png" alt=""></p>
<p>Ветвь (Branch) — это путь от Корня до Листа, а раз Лист — это узел, не имеющий дочерних узлов (в нашем случае это узлы со значениями 5, 3 и 4), то в этом примере будет три ветви Дерева:</p>
<p style="display: flex; justify-content: center;"><img src="./asset-v1_SkillFactory+QAP-3.0+2021+type@asset+block@module_22.13.png" alt=""></p>
<p>Следующим понятием будет Глубина (Depth), то есть количество узлов на пути от корня до узла. Глубина корня считается равной 0, а глубина каждого последующего узла равна глубине его родительского узла плюс 1. Поэтому в примере выше глубина узла со значением 5 равна двум.</p>
<p>И, наконец, Высота (Height) — это максимальная глубина дерева. В нашем случае она тоже равна двум, поскольку глубина двух остальных ветвей равна 1.</p>
<p></p>
<p><strong>Где используется структура Дерево</strong></p>
<p></p>
<p>Самый очевидный кейс из реального мира — хранение иерархических данных. В первую очередь то, с чем знаком каждый из нас — это файловая система, но также деревьями можно представлять структуру организаций или, например, родословные.</p>
<p>Также деревья применимы в контексте задачи поиска информации, но для этого используются бинарные деревья. Организуя поиск по такой структуре мы значительно выигрываем по времени. Всё это, конечно, зависит от конкретной постановки задачи.</p>
<p>И, пожалуй, второй по популярности кейс применения деревьев — это деревья решений, где есть некая начальная точка (Корень), которая является вопросом, а Ветви символизируют возможные пути решений. Они тоже в свою очередь представляют собой вопросы, но уже новые, ответив на которые мы дойдем до нужного Листа — решения.</p>
<p>А мы сейчас с вами разберем классическую задачу представления файловой системы компьютера с помощью n-арного дерева.</p>
<p><strong>Реализация файловой системы с помощью N-aрного дерева.</strong></p>
<p></p>
<p>В файловой системе каждая директория (Узел) имеет набор вложенных директорий (Дочерних узлов) и файлов (Листьев).</p>
<p>Вот с чего можно начать:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        self.name = name
        self.children = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_child</span>(<span class="hljs-params">self, child</span>):
        self.children.append(child)


root = TreeNode(<span class="hljs-string">"C:"</span>)</pre>
<p>Теперь нужно заполнить файловую систему, то есть добавить больше Узлов и Деревьев. Давайте создадим две папки с файлами и один файл положим в корень:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">documents = TreeNode(<span class="hljs-string">"Documents"</span>)
root.add_child(documents)
documents.add_child(TreeNode(<span class="hljs-string">"Homework.docx"</span>))
documents.add_child(TreeNode(<span class="hljs-string">"Report.docx"</span>))

pictures = TreeNode(<span class="hljs-string">"Pictures"</span>)
root.add_child(pictures)
pictures.add_child(TreeNode(<span class="hljs-string">"Summer.jpg"</span>))
pictures.add_child(TreeNode(<span class="hljs-string">"Winter.jpg"</span>))

root.add_child(TreeNode(<span class="hljs-string">'secret.key'</span>))</pre>
<p>Формально, задача решена, так как файловую систему мы интерпретировали. Но самое важное начинается тогда, когда вы начнете с ней взаимодействовать. Первоочередная проблема — это визуализация, решить её поможет следующая функция:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_file_system</span>(<span class="hljs-params">node, indent=<span class="hljs-string">""</span></span>):
    <span class="hljs-built_in">print</span>(indent + node.name + (<span class="hljs-string">"/"</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> node.children <span class="hljs-keyword">else</span> <span class="hljs-string">"\\"</span>))
    <span class="hljs-keyword">if</span> node.children:
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children:
            print_file_system(child, indent + <span class="hljs-string">"  "</span>)</pre>
<p>Функция <code>print_file_system()</code> принимает два аргумента — <code>node</code>, который представляет текущий узел и с которого начинается обход, и <code>indent</code>, который используется для добавления отступов перед именем узла при выводе.</p>
<p>Сначала функция выводит информацию о текущем узле. Здесь <code>indent </code>используется для создания отступа перед именем узла. Если узел является файлом (<code>not node.children</code> — отсутствуют дочерние узлы), используется символ <code>"/"</code> для обозначения файла, в противном случае используется символ<code> "\" </code>для обозначения директории.</p>
<p>Далее функция проверяет, есть ли у текущего узла Дочерние узлы. Это делается с помощью условия <code>if node.children</code>:</p>
<ul class="list">
<li>Если у узла есть нет дочерних узлов, обход этой ветви завершается.</li>
<li>Если же у узла есть дочерние узлы, то функция начинает обход каждого из них. Для этого используется цикл <code>for child in node.children</code>:.</li>
</ul>
<p>Внутри цикла для каждого дочернего узла рекурсивно вызывается функция <code>print_file_system()</code>. При этом передается текущий дочерний узел в качестве аргумента <code>node</code>, а также добавляется отступ <code>indent + " "</code>, чтобы текст выводился с отступом относительно родительского узла</p>
<p>Этот процесс продолжается для каждого дочернего узла рекурсивно, пока не будет достигнута конечная точка, то есть узлы без дочерних элементов Листья.</p>
<p>И смотрим на результат:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">print_file_system(root)
<span class="hljs-comment"># C:\</span>
<span class="hljs-comment">#      Documents\</span>
<span class="hljs-comment">#           Homework.docx/</span>
<span class="hljs-comment">#           Report.docx/</span>
<span class="hljs-comment">#      Pictures\</span>
<span class="hljs-comment">#           Summer.jpg/</span>
<span class="hljs-comment">#           Winter.jpg/</span>
<span class="hljs-comment">#      secret.key/</span></pre>
<p>Теперь можно перейти к следующей важной теме — алгоритмы поиска в деревьях.</p>
<p></p>
<div class="h3">Алгоритмы поиска в деревьях</div>
<p></p>
<p>Существует множество алгоритмов, которые работают с деревьями. Мы же посмотрим на два самых распространенных, которые решают задачу поиска — это алгоритм поиска в глубину (Depth-First Search, DFS), который для обхода дерева посещает сначала все узлы на одной ветви, перед тем как перейти к следующей, и алгоритм поиска в ширину (Breadth-First Search, BFS), который наоборот посещает узлы по уровням, начиная с самого корня и поэтапно спускаясь на уровень ниже.</p>
<p>Вы уже увидели, как обходить дерево, поэтому реализовать алгоритм поиска в глубину для вас не составит труда. Давайте сразу посмотрим на алгоритм, поскольку он похож на функцию визуализации файловой системы:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">def</span> <span class="hljs-title function_">depth_first_search_for_file</span>(<span class="hljs-params">node, target_file</span>):
    <span class="hljs-keyword">if</span> node.name == target_file:
        <span class="hljs-keyword">return</span> node
    <span class="hljs-keyword">if</span> node.children:
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children:
            result = depth_first_search_for_file(child, target_file)
            <span class="hljs-keyword">if</span> result:
                <span class="hljs-keyword">return</span> result
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></pre>
<p>Функция <code>depth_first_search_for_file()</code> принимает два аргумента: <code>node</code>, который является текущим узлом для обработки, и <code>target_file</code>, то есть имя файла, который мы ищем в Дереве. Не обязательно указывать <code>root</code>, если вы хотите запустить поиск в определенной папке, но важно понимать, что здесь передается именно объект.</p>
<p>Сначала функция проверяет базовый случай. Если имя текущего узла совпадает с искомым файлом, то файл найден и функция возвращает этот узел:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">if</span> node.name == target_file:
    <span class="hljs-keyword">return</span> node</pre>
<p>Если имя текущего узла не совпадает с искомым файлом, функция проверяет, есть ли у этого узла дети (подузлы). Если есть, она рекурсивно вызывает себя для каждого дочернего файла:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">if</span> node.children:
    <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children:
        result = depth_first_search_for_file(child, target_file)
        <span class="hljs-keyword">if</span> result:
            <span class="hljs-keyword">return</span> result</pre>
<p>При рекурсивном вызове <code>depth_first_search_for_file(child, target_file)</code> мы передаём текущий дочерний узел child в качестве нового текущего узла для обработки.</p>
<p>Если рекурсивный вызов находит искомый файл где-то в поддереве, он возвращает соответствующий узел. В противном случае, если файл не найден в текущем поддереве или в поддеревьях, функция возвращает <code>None</code>.</p>
<p>Получается следующий результат:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">found_node = depth_first_search_for_file(root, <span class="hljs-string">'Report.docx'</span>)
<span class="hljs-built_in">print</span>(found_node.name) <span class="hljs-comment"># Report.docx</span></pre>
<p>В текущей реализации возвращается объект класса <code>TreeNode </code>со значением атрибута <code>name</code>, который вы задали при поиске. Именно так решается задача проверки существования файла. Но можно продвинуться дальше и возвращать пользователю путь до этого файла, если он был найден:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">def</span> <span class="hljs-title function_">depth_first_search_for_file</span>(<span class="hljs-params">node, target_file, current_path=<span class="hljs-string">""</span></span>):
    <span class="hljs-comment"># Обновляем текущий путь, добавляя текущее имя узла</span>
    current_path += node.name + <span class="hljs-string">"/"</span>

    <span class="hljs-keyword">if</span> node.name == target_file:
        <span class="hljs-comment"># Если имя текущего узла совпадает с искомым файлом, возвращаем текущий путь</span>
        <span class="hljs-keyword">return</span> current_path

    <span class="hljs-keyword">if</span> node.children:
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children:
            <span class="hljs-comment"># Рекурсивно вызываем функцию для каждого ребенка, передавая текущий путь</span>
            result = depth_first_search_for_file(child, target_file, current_path)
            <span class="hljs-keyword">if</span> result:
                <span class="hljs-keyword">return</span> result

    <span class="hljs-comment"># Если файл не найден в текущем поддереве, возвращаем None</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></pre>
<p>Теперь алгоритм поиска пути до файла через обход в глубину полноценно реализован. Теперь давайте обратим внимание на второй алгоритм — алгоритм поиска в ширину (BFS), который итеративно просматривает все узлы на одном уровне перед переходом к узлам на следующем уровне.</p>
<p>Путь до каждого узла, который вы посещаете, сохраняется. Как только вы обнаружили искомый файл, то сможете проследить путь, который привёл к этому файлу. В этом алгоритме пригодится реализованный ранее класс очереди:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>:
   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
       self.queue = []

   <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):
       <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.queue) == <span class="hljs-number">0</span>

   <span class="hljs-keyword">def</span> <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">self, item</span>):
       self.queue.append(item)

   <span class="hljs-keyword">def</span> <span class="hljs-title function_">dequeue</span>(<span class="hljs-params">self</span>):
       <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_empty():
           <span class="hljs-keyword">return</span> self.queue.pop(<span class="hljs-number">0</span>)
       <span class="hljs-keyword">else</span>:
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"Queue is empty"</span>)
           <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></pre>
<p>Так выглядит сам алгоритм:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">def</span> <span class="hljs-title function_">breadth_first_search_for_file</span>(<span class="hljs-params">root, target_file</span>):
    queue = Queue()
    queue.enqueue((root, <span class="hljs-string">""</span>))

    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> queue.is_empty():
        current_node, current_path = queue.dequeue()
        current_path += current_node.name + <span class="hljs-string">"/"</span>

        <span class="hljs-keyword">if</span> current_node.name == target_file:
            <span class="hljs-keyword">return</span> current_path

        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> current_node.children:
            queue.enqueue((child, current_path))

    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></pre>
<p>Давайте разберем его поэтапно. Создаем экземпляр класса <code>Queue </code>для управления очередью:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">queue = Queue()
queue.enqueue((root, <span class="hljs-string">""</span>))</pre>
<p>Начать стоит с корневого узла <code>root </code>и добавить его в очередь вместе с пустым путём. Это означает, что вы начинаете обход с корневой директории.</p>
<p>Далее начинайте итерацию по элементам очереди, пока она не окажется пустой. На каждой итерации извлекайте первый элемент из очереди:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">current_node, current_path = queue.dequeue()</pre>
<div class="term">
<ul class="list">
<li><code>current_node</code> — это текущий узел.</li>
<li><code>current_path</code> — путь до этого узла.</li>
</ul>
</div>
<p>Затем проверяем, совпадает ли имя текущего узла с искомым именем файла:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">if</span> current_node.name == target_file:
    <span class="hljs-keyword">return</span> current_path</pre>
<p>Если совпадение найдено, возвращайте текущий путь:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> current_node.children:
    queue.enqueue((child, current_path))</pre>
<p>Если текущий узел не содержит искомый файл, добавьте все дочерние узлы текущего узла в очередь для дальнейшего обхода:Так мы добавляем каждый дочерний узел в очередь вместе с обновленным путем current_path, включающим имя текущего узла.</p>
<p>Мы продолжаем этот процесс до тех пор, пока очередь не станет пустой или пока не найдем искомый файл. Если файл найден, возвращаем путь до него, в ином случае вернем <code>None</code>.</p>
<p>Результат будет идентичен предыдущему:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">file_path = breadth_first_search_for_file(root, <span class="hljs-string">'Report.docx'</span>)
<span class="hljs-keyword">if</span> file_path: <span class="hljs-comment"># Если файл был найден</span>
    <span class="hljs-built_in">print</span>(file_path[:-<span class="hljs-number">1</span>])
<span class="hljs-comment"># C:/Documents/Report.docx</span>
</pre>
<p>Важно уточнить, что алгоритмов обхода дерева существует несколько, причем для каждого вида деревьев используются свои алгоритмы.Давайте подробнее рассмотрим конкретно наш случай — <strong>N-арное дерево</strong> и алгоритмы <strong>DFS</strong> и <strong>BFS</strong>.</p>
<p>Алгоритм поиска в глубину (DFS) следует использовать, когда вы хотите найти решение как можно быстрее, не беспокоясь об оптимальности пути к целевому узлу. Алгоритм поиска в ширину (BFS) используется, когда вам важно найти кратчайшее, оптимальное решение.</p>
<p>Если требуется найти путь к конкретному файлу в файловой системе без учета кратчайшего пути, алгоритм поиска в глубину может быть предпочтительнее. Однако, если важно найти кратчайший путь к файлу, тогда алгоритм поиска в ширину может быть более подходящим выбором.</p>
<p>Важно учесть еще один момент — описанный выше алгоритм не учитывает ситуацию, когда в файловой системе находится несколько файлов с одинаковым именем. Эту задачу вам нужно будет решить в практический части юнита.</p>
<p></p>
<div class="h3">Графы</div>
<p></p>
<div class="term"><strong>Граф</strong> — это еще одна нелинейная структура данных, которая используется для представления взаимосвязей между объектами. Граф состоит из узлов (вершин) и ребер (связей между узлами).</div>
<p style="display: flex; justify-content: center;"><img src="./asset-v1_SkillFactory+QAP-3.0+2021+type@asset+block@module_22.14.png" alt=""></p>
<p style="display: flex; justify-content: center;" class="grey-text"><span><a href="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/220px-6n-graf.svg.png" target="_blank" rel="noopener">Источник</a></span></p>
<p>При работе с Графами, как и с Деревьями, тоже важно четко понимать используемую терминологию. Сейчас вы можете ознакомиться с основными терминами в теории Графов, а затем мы перейдем к их освоению на практике:</p>
<div class="term">
<ul class="list">
<li><strong>Узел (вершина, Node)</strong> — элемент графа, представляющий объект.</li>
<li><strong>Ребро (Edge)</strong> — связь между двумя узлами.</li>
<li><strong>Путь (Path)</strong> —последовательность ребер, соединяющих два узла.</li>
<li><strong>Цикл (Cycle)</strong> — путь, который начинается и заканчивается в одном и том же узле.</li>
<li><strong>Направленный граф (Directed Graph)</strong> — граф, в котором ребра имеют направление, указывающее, как можно перемещаться между узлами.</li>
<li><strong>Ненаправленный граф (Undirected Graph)</strong> — граф, в котором ребра не имеют направления.</li>
<li><strong>Взвешенный граф (Weighted Graph) </strong>— граф, в котором ребрам назначены веса (числа), представляющие стоимость или расстояние между узлами.</li>
</ul>
</div>
<p></p>
<p><strong>Способы представления графов</strong></p>
<p></p>
<p>Список смежности (Adjacency List). В этом случае для каждого узла хранится список узлов, с которыми он соединен ребрами:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">graph = {
    <span class="hljs-string">'A'</span>: [<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>],
    <span class="hljs-string">'B'</span>: [<span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>],
    <span class="hljs-string">'C'</span>: [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'D'</span>],
    <span class="hljs-string">'D'</span>: [<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>]
}</pre>
<p>Каждый ключ в словаре представляет узел графа, а значение для каждого ключа — список смежных узлов.</p>
<p>Преимущество такого представления заключается в эффективном представлении разреженных графов (граф, в котором количество рёбер значительно меньше, чем максимально возможное количество рёбер между вершинами) и экономии памяти, поскольку мы храним информацию только о смежных узлах.</p>
<p>К недостаткам этого способа можно отнести медленное выполнение проверки на существование ребра между двумя узлами.</p>
<p>Матрица смежности (Adjacency Matrix). Матрица, в которой строки и столбцы соответствуют узлам, а значение в ячейке (i, j) указывает, есть ли ребро между узлами i и j.</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">graph = [
    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]
]</pre>
<p>В данном примере каждая строка и каждый столбец матрицы представляют узлы графа. Значение 1 в ячейке указывает на наличие ребра между соответствующими узлами, а значение 0 указывает на его отсутствие.</p>
<p>Здесь наоборот матрица смежности эффективнее представляет плотные графы (количество рёбер близко к максимально возможному количеству рёбер между вершинами), и доступ к проверке существования ребра между двумя узлами осуществляется быстрее.</p>
<p>К недостаткам такого представления можно отнести расход памяти для больших и разреженных графов и неэффективное хранение информации для большого количества узлов в разреженном графе.</p>
<div class="color-container container-flex blue-container">
<div class="container-icon"><svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26" fill="none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M6.99581 3.99658C6.99581 6.20664 5.2042 7.99825 2.99414 7.99825C5.2042 7.99825 6.99581 9.78986 6.99581 11.9999C6.99581 9.78986 8.78741 7.99825 10.9975 7.99825C8.78741 7.99825 6.99581 6.20664 6.99581 3.99658Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M18.0021 16.0017C18.0021 13.2392 15.7626 10.9996 13 10.9996C15.7626 10.9996 18.0021 8.76013 18.0021 5.99756C18.0021 8.76013 20.2416 10.9996 23.0042 10.9996C20.2416 10.9996 18.0021 13.2392 18.0021 16.0017Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M10.9978 14.501C10.9978 16.711 9.20615 18.5026 6.99609 18.5026C9.20615 18.5026 10.9978 20.2942 10.9978 22.5043C10.9978 20.2942 12.7894 18.5026 14.9994 18.5026C12.7894 18.5026 10.9978 16.711 10.9978 14.501Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> </svg></div>
<span>Выбор между этими способами представления зависит от характеристик самого графа и требований к его обработке.</span></div>
<p></p>
<p><strong>Где применяются Графы</strong></p>
<p></p>
<p>На самом деле, Графы применяются в самых ближайших практически для каждого человека сферах. В основе тех же социальных сетей лежат графы, моделирующие взаимосвязи между пользователям. В списках друзей узлы — это конкретные люди, а ребра — связи между ними, например,добавление в друзья, подписки и лайки.</p>
<p>Еще одна сфера — картографические системы и навигация. Современные алгоритмы навигации по крупным городам очень сложны, но если их упростить, то у нас будут пункты назначения (узлы) и пути между ними (ребра). В таких графах можно находить кратчайшие пути от точки А к точке Б, чем мы сегодня с вами и займемся.</p>
<p>К менее общеизвестной сфере применения графов можно отнести биоинформатику, в ней графы помогают исследовать сложные сети взаимосвязей.</p>
<p></p>
<p><strong>Какие алгоритмы можно применять к Графам</strong></p>
<p></p>
<ul class="list">
<li>Самый первый алгоритм, который изучают при знакомстве с графами — это Алгоритм Дейкстры, который служит для нахождения кратчайших путей от одного узла до всех остальных узлов во взвешенном графе.</li>
<li>Но поскольку Алгоритм Дейкстры не совсем универсален (с его ограничениями познакомимся при подробном его рассмотрении), то прибегают и к другим алгоритмам, например Алгоритму Беллмана-Форда, который помогает решать задачу нахождения кратчайших путей в графе с отрицательными весами ребер.</li>
</ul>
<p>Для практического освоения графов давайте рассмотрим задачу по поиску кратчайшего пути и разберем реализацию алгоритма Дейкстры.</p>
<p></p>
<div class="h3">Поиск кратчайшего пути. Алгоритм Дейкстры</div>
<p></p>
<p>Представьте, что у вас есть карта, на которой отмечены города и дороги между ними. Вы хотите найти кратчайший путь между двумя заданными городами. Сначала вам нужно представить карту в виде графа: города у будут представлены узлами графа, а дороги — ребрами. Если дороги имеют разную длину, можно назначить рёбрам веса, соответствующие их длине.</p>
<p>Теперь можно представить граф с помощью словаря, где ключи — это узлы, а значения — списки смежных узлов. Это будет взвешенный граф, так как дороги имеют длину.</p>
<p>Вы можете использовать словарь, где значения — это словари, сопоставляющие смежные узлы с их весами.</p>
<p>Давайте сравним пример ненаправленного графа, в котором у рёбер нет стоимости поездки, то есть в контексте нашей задачи — длины пути:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">graph = {
    <span class="hljs-string">'A'</span>: [<span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>],
    <span class="hljs-string">'B'</span>: [<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>],
    <span class="hljs-string">'C'</span>: [<span class="hljs-string">'A'</span>, <span class="hljs-string">'F'</span>],
    <span class="hljs-string">'D'</span>: [<span class="hljs-string">'B'</span>],
    <span class="hljs-string">'E'</span>: [<span class="hljs-string">'B'</span>, <span class="hljs-string">'F'</span>],
    <span class="hljs-string">'F'</span>: [<span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>]
}</pre>
<p>А вот пример взвешенного графа, где уже указана стоимость поездки по выбранному пути:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">weighted_graph = {
    <span class="hljs-string">'A'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'C'</span>: <span class="hljs-number">2</span>},
    <span class="hljs-string">'B'</span>: {<span class="hljs-string">'A'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'D'</span>: <span class="hljs-number">4</span>, <span class="hljs-string">'E'</span>: <span class="hljs-number">3</span>},
    <span class="hljs-string">'C'</span>: {<span class="hljs-string">'A'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'F'</span>: <span class="hljs-number">7</span>},
    <span class="hljs-string">'D'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">4</span>},
    <span class="hljs-string">'E'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'F'</span>: <span class="hljs-number">6</span>},
    <span class="hljs-string">'F'</span>: {<span class="hljs-string">'C'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'E'</span>: <span class="hljs-number">6</span>}
}</pre>
<p>По такому словарю достаточно трудно визуализировать эту задачу, поэтому давайте посмотрим на пример кода, который позволяет визуализировать графы при помощи библиотек <code>networkx </code>и <code>matplotlib</code>:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

weighted_graph = {
   <span class="hljs-string">'A'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'C'</span>: <span class="hljs-number">2</span>},
   <span class="hljs-string">'B'</span>: {<span class="hljs-string">'A'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'D'</span>: <span class="hljs-number">4</span>, <span class="hljs-string">'E'</span>: <span class="hljs-number">3</span>},
   <span class="hljs-string">'C'</span>: {<span class="hljs-string">'A'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'F'</span>: <span class="hljs-number">7</span>},
   <span class="hljs-string">'D'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">4</span>},
   <span class="hljs-string">'E'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'F'</span>: <span class="hljs-number">6</span>},
   <span class="hljs-string">'F'</span>: {<span class="hljs-string">'C'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'E'</span>: <span class="hljs-number">6</span>}
}

<span class="hljs-comment"># Создаем направленный граф</span>
G = nx.DiGraph()

<span class="hljs-comment"># Добавляем узлы и ребра в граф</span>
<span class="hljs-keyword">for</span> node, edges <span class="hljs-keyword">in</span> weighted_graph.items():
   G.add_node(node)
   <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> edges.items():
       G.add_edge(node, neighbor, weight=weight)


pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=<span class="hljs-literal">True</span>, node_size=<span class="hljs-number">1000</span>, node_color=<span class="hljs-string">'lightblue'</span>, font_size=<span class="hljs-number">12</span>, font_weight=<span class="hljs-string">'bold'</span>)
labels = nx.get_edge_attributes(G, <span class="hljs-string">'weight'</span>)
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

plt.show()</pre>
<p>Так будет выглядеть результат:</p>
<p style="display: flex; justify-content: center;"><img src="./asset-v1_SkillFactory+QAP-3.0+2021+type@asset+block@module_22.15.png" alt=""></p>
<p>Теперь ваша задача — реализовать такую программу, которая находила бы кратчайший путь из одного узла графа в другой. В этом поможет алгоритм Дейкстры, как раз созданный для нахождения кратчайших путей от одного узла (источника) до всех остальных узлов во взвешенном графе. Реализовав такой алгоритм, вам останется только выбрать кратчайший путь до нужного узла.</p>
<div class="color-container container-flex blue-container">
<div class="container-icon"><svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26" fill="none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M6.99581 3.99658C6.99581 6.20664 5.2042 7.99825 2.99414 7.99825C5.2042 7.99825 6.99581 9.78986 6.99581 11.9999C6.99581 9.78986 8.78741 7.99825 10.9975 7.99825C8.78741 7.99825 6.99581 6.20664 6.99581 3.99658Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M18.0021 16.0017C18.0021 13.2392 15.7626 10.9996 13 10.9996C15.7626 10.9996 18.0021 8.76013 18.0021 5.99756C18.0021 8.76013 20.2416 10.9996 23.0042 10.9996C20.2416 10.9996 18.0021 13.2392 18.0021 16.0017Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M10.9978 14.501C10.9978 16.711 9.20615 18.5026 6.99609 18.5026C9.20615 18.5026 10.9978 20.2942 10.9978 22.5043C10.9978 20.2942 12.7894 18.5026 14.9994 18.5026C12.7894 18.5026 10.9978 16.711 10.9978 14.501Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> </svg></div>
<span><strong>Давайте посмотрим на общий алгоритм Дейкстры:</strong><br><br>1. <strong>Инициализация</strong>. Установить начальную вершину и расстояние до нее как 0, а до всех остальных вершин как бесконечность. Создать пустое множество для хранения вершин, которые еще не были посещены.<br><br>2. <strong>Выбор вершины</strong>. Из всех непосещенных вершин выбрать ту, расстояние до которой будет наименьшим.<br><br>3. <strong>Обновление расстояний</strong>. Для каждой смежной вершины, которая еще не посещена, вычислить новое расстояние как сумму расстояния до текущей вершины и веса ребра до смежной вершины. Если новое расстояние меньше, чем текущее, обновить расстояние. <br><br>4. <strong>Отметка вершины, как посещенной</strong>. После обновления расстояний для всех смежных вершин пометить текущую вершину как посещенную и исключить ее из множества непосещенных вершин. <br><br>5.<strong> Повтор.</strong> Повторить шаги 2-4, пока все вершины не будут посещены. </span></div>
<p>Теперь самое сложное — реализация. Начинаем с инициализации:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict


<span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, source</span>):
    distances = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">float</span>(<span class="hljs-string">'inf'</span>))  <span class="hljs-comment"># Создаем словарь для хранения расстояний до каждой вершины</span>
    previous = {}  <span class="hljs-comment"># Словарь для хранения предыдущей вершины на пути к каждой вершине</span>
    unvisited = <span class="hljs-built_in">set</span>(graph.keys())  <span class="hljs-comment"># Множество непосещенных вершин</span>

    distances[source] = <span class="hljs-number">0</span>  <span class="hljs-comment"># Устанавливаем расстояние до начальной вершины как 0</span></pre>
<p>Первое пояснение — алгоритм принимает <code>weighted_graph </code>и имя узла, от которого мы будем искать кратчайшие пути до всех узлов:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">distances, previous = dijkstra(weighted_graph, <span class="hljs-string">'D'</span>) </pre>
<p>С previous и unvisited всё более или менее очевидно, но вот с <code>defaultdictt </code>лучше разобраться.</p>
<div class="term"><code>defaultdict </code>— это подкласс словаря из модуля <code>collections</code>, который предоставляет удобный способ создания словаря с заданным значением по умолчанию для каждого ключа. В данном контексте <code>defaultdict </code>используется для хранения расстояний от начальной вершины до всех остальных вершин графа.</div>
<p>В коде используется <code>defaultdict </code>вместе с лямбда-функцией, которая возвращает <code>float('<span style="color: rgb(111, 162, 8);">inf</span>')</code>, то есть положительную бесконечность. Это означает, что изначально все расстояния до вершин, кроме начальной, устанавливаются как бесконечность, потому что мы еще не знаем реальных расстояний до них. Бесконечность выбирается для того, чтобы в начале алгоритма они были неопределенными и постепенно уточнялись в процессе выполнения алгоритма.</p>
<p>В алгоритме Дейкстры используется значение бесконечности <code>('<span style="color: rgb(111, 162, 8);">inf</span>')</code>, чтобы инициализировать расстояния до всех вершин, кроме начальной, перед тем как алгоритм начнет обновлять их на основе фактических расстояний. Когда алгоритм обнаруживает новый кратчайший путь к вершине, он обновляет ее расстояние в словаре расстояний (<code>distances</code>).</p>
<p>Использование <code>defaultdict(<span style="color: rgb(224, 62, 45);">lambda</span>: float('<span style="color: rgb(111, 162, 8);">inf</span>'))</code> позволяет избежать проверки наличия ключей в словаре при каждом обновлении расстояний. Если ключ отсутствует, <code>defaultdict </code>автоматически создает новую запись с указанным значением по умолчанию, в данном случае <code>float('<span style="color: rgb(111, 162, 8);">inf</span>')</code>, что делает код более компактным и читаемым.</p>
<p>Продолжаем разработку алгоритма:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, source</span>):
    distances = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">float</span>(<span class="hljs-string">'inf'</span>))  <span class="hljs-comment"># Создаем словарь для хранения расстояний до каждой вершины</span>
    previous = {}  <span class="hljs-comment"># Словарь для хранения предыдущей вершины на пути к каждой вершине</span>
    unvisited = <span class="hljs-built_in">set</span>(graph.keys())  <span class="hljs-comment"># Множество непосещенных вершин</span>

    distances[source] = <span class="hljs-number">0</span>  <span class="hljs-comment"># Устанавливаем расстояние до начальной вершины как 0</span>

    <span class="hljs-keyword">while</span> unvisited:
        current_node = <span class="hljs-built_in">min</span>(unvisited, key=<span class="hljs-keyword">lambda</span> node: distances.get(node, <span class="hljs-built_in">float</span>(
            <span class="hljs-string">'inf'</span>)))
        unvisited.remove(current_node)</pre>
<p>Алгоритм <code>while unvisited</code>: будет работать до тех пор, пока существуют непосещенные вершины. Для начала нужно выбрать вершину с наименьшим расстоянием:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">current_node = <span class="hljs-built_in">min</span>(unvisited, key=<span class="hljs-keyword">lambda</span> node: distances.get(node, <span class="hljs-built_in">float</span>(<span class="hljs-string">'inf'</span>))) </pre>
<div class="term"><code>unvisited </code>— это множество непосещенных вершин. На каждой итерации алгоритма оно содержит только те вершины, которые еще не были посещены.</div>
<p>Вторым аргументом будет критерий сравнения вершин между собой — <code>key=<span style="color: rgb(186, 55, 42);">lambda </span>node: distances.get(node, float('<span style="color: rgb(111, 162, 8);">inf'</span>))</code>.</p>
<p>Здесь используется лямбда-функция, которая принимает вершину node и возвращает расстояние от начальной вершины до этой вершины. Если расстояние до вершины не определено (то есть вершина еще не была посещена и нет соответствующей записи в словаре <code>distances</code>), мы возвращаем бесконечность<code> float('<span style="color: rgb(111, 162, 8);">inf</span>')</code>. Это гарантирует, что непосещенные вершины будут иметь наименьший приоритет при выборе следующей вершины для посещения.</p>
<p>Сам вызов функции <code>min(unvisited, key=</code> возвращает минимальный элемент из непосещенных вершин <code>unvisited</code>, используя критерий, определенный в <code>key</code>, для определения порядка сравнения. Таким образом, алгоритм выбирает вершину с наименьшим расстоянием от начальной вершины.</p>
<div class="color-container container-flex blue-container">
<div class="container-icon"><svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26" fill="none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M6.99581 3.99658C6.99581 6.20664 5.2042 7.99825 2.99414 7.99825C5.2042 7.99825 6.99581 9.78986 6.99581 11.9999C6.99581 9.78986 8.78741 7.99825 10.9975 7.99825C8.78741 7.99825 6.99581 6.20664 6.99581 3.99658Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M18.0021 16.0017C18.0021 13.2392 15.7626 10.9996 13 10.9996C15.7626 10.9996 18.0021 8.76013 18.0021 5.99756C18.0021 8.76013 20.2416 10.9996 23.0042 10.9996C20.2416 10.9996 18.0021 13.2392 18.0021 16.0017Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M10.9978 14.501C10.9978 16.711 9.20615 18.5026 6.99609 18.5026C9.20615 18.5026 10.9978 20.2942 10.9978 22.5043C10.9978 20.2942 12.7894 18.5026 14.9994 18.5026C12.7894 18.5026 10.9978 16.711 10.9978 14.501Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> </svg></div>
<span>Итак, строка <code>current_node = min(unvisited, key=<span style="color: rgb(186, 55, 42);">lambda </span>node: distances.get(node, float('<span style="color: rgb(111, 162, 8);">inf</span>')))</code> на каждой итерации выбирает вершину с наименьшим текущим расстоянием от начальной вершины, учитывая, что непосещенные вершины имеют приоритет над уже посещенными, и вершины без определенного расстояния считаются как имеющие бесконечное расстояние.</span></div>
<p>Теперь нужно отметить вершину, как посещенную:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">unvisited.remove(current_node) </pre>
<p>Наконец, финальная часть алгоритма:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, source</span>):
    distances = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">float</span>(<span class="hljs-string">'inf'</span>))  <span class="hljs-comment"># Создаем словарь для хранения расстояний до каждой вершины</span>
    previous = {}  <span class="hljs-comment"># Словарь для хранения предыдущей вершины на пути к каждой вершине</span>
    unvisited = <span class="hljs-built_in">set</span>(graph.keys())  <span class="hljs-comment"># Множество непосещенных вершин</span>

    distances[source] = <span class="hljs-number">0</span>  <span class="hljs-comment"># Устанавливаем расстояние до начальной вершины как 0</span>

    <span class="hljs-keyword">while</span> unvisited:  <span class="hljs-comment"># Пока есть непосещенные вершины</span>
        current_node = <span class="hljs-built_in">min</span>(unvisited, key=<span class="hljs-keyword">lambda</span> node: distances.get(node, <span class="hljs-built_in">float</span>(
            <span class="hljs-string">'inf'</span>)))  <span class="hljs-comment"># Выбираем вершину с наименьшим расстоянием</span>
        unvisited.remove(current_node)  <span class="hljs-comment"># Помечаем вершину как посещенную</span>

        <span class="hljs-comment"># Финальная часть алгоритма:</span>
        <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[current_node].items():
            new_distance = distances[current_node] + weight
            <span class="hljs-keyword">if</span> new_distance &lt; distances[neighbor]:
                distances[neighbor] = new_distance 
                previous[
                    neighbor] = current_node 

    <span class="hljs-keyword">return</span> distances, previous</pre>
<p>Для каждой смежной вершины:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[current_node].items()</pre>
<p>Вычисляется новое расстояние:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">new_distance = distances[current_node] + weight</pre>
<p>И если новое расстояние меньше текущего:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">if</span> new_distance &lt; distances[neighbor]:</pre>
<p>То обновите расстояние и установите текущую вершину, как предыдущую на пути к смежной вершине:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">                distances[neighbor] = new_distance 
                previous[neighbor] = current_node </pre>
<p>Дальше возвращаем словарь расстояний и словарь предыдущих вершин:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">return</span> distances, previous</pre>
<p>Итоговая функция будет выглядеть так:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict


<span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">graph, source</span>):
    distances = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">float</span>(<span class="hljs-string">'inf'</span>))  
    previous = {}  
    unvisited = <span class="hljs-built_in">set</span>(graph.keys()) 

    distances[source] = <span class="hljs-number">0</span>  

    <span class="hljs-keyword">while</span> unvisited:  <span class="hljs-comment"># Пока есть непосещенные вершины</span>
        current_node = <span class="hljs-built_in">min</span>(unvisited, key=<span class="hljs-keyword">lambda</span> node: distances.get(node, <span class="hljs-built_in">float</span>(
            <span class="hljs-string">'inf'</span>))) 
        unvisited.remove(current_node)  

        <span class="hljs-comment"># Финальная часть алгоритма:</span>
        <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[current_node].items():  
            new_distance = distances[current_node] + weight 
            <span class="hljs-keyword">if</span> new_distance &lt; distances[neighbor]:  
                distances[neighbor] = new_distance 
                previous[
                    neighbor] = current_node 

    <span class="hljs-keyword">return</span> distances, previous  </pre>
<p>Пробуйте применить алгоритм к нашему графу:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">weighted_graph = {
    <span class="hljs-string">'A'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'C'</span>: <span class="hljs-number">2</span>},
    <span class="hljs-string">'B'</span>: {<span class="hljs-string">'A'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'D'</span>: <span class="hljs-number">4</span>, <span class="hljs-string">'E'</span>: <span class="hljs-number">3</span>},
    <span class="hljs-string">'C'</span>: {<span class="hljs-string">'A'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'F'</span>: <span class="hljs-number">7</span>},
    <span class="hljs-string">'D'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">4</span>},
    <span class="hljs-string">'E'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'F'</span>: <span class="hljs-number">6</span>},
    <span class="hljs-string">'F'</span>: {<span class="hljs-string">'C'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'E'</span>: <span class="hljs-number">6</span>}
}

<span class="hljs-comment"># Находим кратчайшие пути от узла 'D'</span>
distances, previous = dijkstra(weighted_graph, <span class="hljs-string">'D'</span>)
<span class="hljs-built_in">print</span>(distances)
<span class="hljs-comment"># defaultdict(&lt;function dijkstra.&lt;locals&gt;.&lt;lambda&gt; at 0x0000019924F4FBA0&gt;,</span>
<span class="hljs-comment"># {'D': 0,</span>
<span class="hljs-comment"># 'B': 4,</span>
<span class="hljs-comment"># 'A': 9,</span>
<span class="hljs-comment"># 'E': 7,</span>
<span class="hljs-comment"># 'F': 13,</span>
<span class="hljs-comment"># 'C': 11})</span>
<span class="hljs-built_in">print</span>(previous)  <span class="hljs-comment"># {'B': 'D', 'A': 'B', 'E': 'B', 'F': 'E', 'C': 'A'}</span></pre>
<p>На данном этапе, выход алгоритма не совсем очевидно-читаем, поэтому важно пояснить:</p>
<div class="block-example">
<p>Словарь <code>distances </code>содержит кратчайшие расстояния от начальной вершины (в данном случае от вершины 'D') до всех остальных вершин в графе. Ключи словаря — это вершины графа, а значения — расстояния от начальной вершины до соответствующей вершины.</p>
<p>То есть 'D': 0 говорит о том, что расстояние от вершины 'D' до самой себя (начальная вершина) равно 0, затем 'B': 4 значит, что кратчайшее расстояние от вершины 'D' до вершины 'B' равно 4, и так далее.</p>
<p>Словарь <code>previous </code>содержит информацию о предыдущей вершине на пути к каждой вершине. Ключи словаря — это вершины графа, а значения — предыдущие вершины на кратчайшем пути от начальной вершины до соответствующей вершины.</p>
<p>В нашем примере словарь <code>previous </code>говорит:'B': 'D', это значит, что предыдущая вершина на кратчайшем пути от 'D' до 'B' — 'D'. Затем 'A': 'B' значит, что предыдущая вершина на кратчайшем пути от 'D' до 'A' — 'B' и так далее.</p>
</div>
<p>Делаем вывод:</p>
<ul class="list">
<li>из вершины 'D' самый короткий путь к вершине 'B' проходит через вершину 'D';</li>
<li>к вершине 'A' — через вершину 'B';</li>
<li>к вершине 'E' — также через вершину 'B';</li>
<li>к вершине 'F' — через вершину 'E';</li>
<li>к вершине 'C' — через вершину 'A'.</li>
</ul>
<p>Теперь можно найти кратчайший путь:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_shortest_path</span>(<span class="hljs-params">previous, source, target</span>):
    path = [target]  <span class="hljs-comment"># Начинаем с целевой вершины</span>
    <span class="hljs-keyword">while</span> path[-<span class="hljs-number">1</span>] != source:  <span class="hljs-comment"># Пока не достигнем начальной вершины</span>
        path.append(previous[path[-<span class="hljs-number">1</span>]])  <span class="hljs-comment"># Добавляем предыдущую вершину на путь к текущей вершине</span>
    path.reverse()  <span class="hljs-comment"># Переворачиваем список, чтобы путь был от начальной вершины к целевой</span>
    <span class="hljs-keyword">return</span> path</pre>
<p>Смотрим на результат:</p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">weighted_graph = {
    <span class="hljs-string">'A'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'C'</span>: <span class="hljs-number">2</span>},
    <span class="hljs-string">'B'</span>: {<span class="hljs-string">'A'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'D'</span>: <span class="hljs-number">4</span>, <span class="hljs-string">'E'</span>: <span class="hljs-number">3</span>},
    <span class="hljs-string">'C'</span>: {<span class="hljs-string">'A'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'F'</span>: <span class="hljs-number">7</span>},
    <span class="hljs-string">'D'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">4</span>},
    <span class="hljs-string">'E'</span>: {<span class="hljs-string">'B'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'F'</span>: <span class="hljs-number">6</span>},
    <span class="hljs-string">'F'</span>: {<span class="hljs-string">'C'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'E'</span>: <span class="hljs-number">6</span>}
}

<span class="hljs-comment"># Находим кратчайшие пути от узла 'D'</span>
distances, previous = dijkstra(weighted_graph, <span class="hljs-string">'D'</span>)
<span class="hljs-comment"># Выводим кратчайший путь от 'D' до 'F'</span>
path = get_shortest_path(previous, <span class="hljs-string">'D'</span>, <span class="hljs-string">'F'</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Кратчайший путь от D до F: <span class="hljs-subst">{path}</span>"</span>)
<span class="hljs-comment"># Кратчайший путь от D до F: ['D', 'B', 'E', 'F']</span></pre>
<p>Повторив эти действия, вы успешно справитесь с поставленной задачей. Давайте теперь сделаем для себя некоторые выводы.</p>
<div class="color-container container-flex blue-container">
<div class="container-icon"><svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26" fill="none"> <path fill-rule="evenodd" clip-rule="evenodd" d="M6.99581 3.99658C6.99581 6.20664 5.2042 7.99825 2.99414 7.99825C5.2042 7.99825 6.99581 9.78986 6.99581 11.9999C6.99581 9.78986 8.78741 7.99825 10.9975 7.99825C8.78741 7.99825 6.99581 6.20664 6.99581 3.99658Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M18.0021 16.0017C18.0021 13.2392 15.7626 10.9996 13 10.9996C15.7626 10.9996 18.0021 8.76013 18.0021 5.99756C18.0021 8.76013 20.2416 10.9996 23.0042 10.9996C20.2416 10.9996 18.0021 13.2392 18.0021 16.0017Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M10.9978 14.501C10.9978 16.711 9.20615 18.5026 6.99609 18.5026C9.20615 18.5026 10.9978 20.2942 10.9978 22.5043C10.9978 20.2942 12.7894 18.5026 14.9994 18.5026C12.7894 18.5026 10.9978 16.711 10.9978 14.501Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke: #adc9fc;"></path> </svg></div>
<span><strong>Алгоритм Дейкстры</strong> — это эффективный алгоритм для нахождения кратчайших путей в графах. Однако, как и любой алгоритм, он имеет <strong>свои ограничения</strong>.<br><br>Во-первых, он <strong>не может работать с отрицательными весами ребер</strong>. Алгоритм Дейкстры предполагает, что все веса ребер неотрицательны. Если в графе есть ребра с отрицательными весами, алгоритм Дейкстры может не найти кратчайший путь. (В этом случае можно использовать алгоритм Беллмана-Форда). <br><br>Во вторых, <strong>проблема в его сложности</strong>. Временная сложность алгоритма Дейкстры зависит от реализации. В наихудшем случае, когда граф представлен матрицей смежности, сложность алгоритма составляет O(V<sup>2</sup>), где V — количество узлов в графе. Если граф представлен списком смежности, сложность алгоритма может быть снижена до O(E log V), где E — количество ребер в графе.</span></div>
<p></p>
<p><b id="docs-internal-guid-01cfb682-7fff-6768-e055-c1a9a613412e"><span>Когда алгоритм Дейкстры перестает быть эффективным</span></b></p>
<p></p>
<p>Как упоминалось выше, сложность алгоритма Дейкстры в наихудшем случае составляет O(V<sup>2</sup>). Это означает, что время выполнения алгоритма может значительно увеличиться с ростом количества узлов и ребер в графе, то есть в графах с большим количеством узлов и ребер.</p>
<p>Также его эффективность снижается в плотно связанных графах, когда каждый узел соединен с большим количеством других узлов. Это может привести к тому, что алгоритм Дейкстры будет выполнять много ненужных вычислений, что значительно снизит его эффективность.</p>
<p></p>
<p><b>Какие есть альтернативы</b></p>
<p></p>
<p>Существуют и другие алгоритмы для нахождения кратчайших путей в графах, которые могут быть более эффективными в определенных ситуациях.</p>
<p>Как упоминалось ранее, алгоритм алгоритм Беллмана-Форда может работать с графами, содержащими ребра с отрицательными весами. Если нужно найти кратчайшие пути между всеми парами узлов в графе, берите алгоритм Флойда-Уоршелла.</p>
<p>Также существует еще один специфичный <a href="https://ru.wikipedia.org/wiki/A*" target="_blank" rel="noopener">алгоритм А-везда</a>, который использует эвристическую функцию для оценки расстояния до целевого узла, что может помочь в ускорении поиска кратчайшего пути.</p>
<p>Из этого можно сделать вывод, что Алгоритм Дейкстры — это достаточно эффективный инструмент для нахождения кратчайших путей в относительно простых Графах. Важно понимать его ограничения и знать, когда он перестает быть эффективным. В этом случае разумно будет прибегнуть к другим алгоритмам, которые в вашей ситуации могут оказаться более предпочтительными.</p>
<p><strong>В этом юните вы погрузились в мир нелинейных структур данных, изучив две фундаментальные структуры: Деревья и Графы</strong>.</p>
<ul class="list">
<li>Вы узнали, что основные компоненты Деревьев — это узлы, корень, листья, ветви, также ему свойственны такие характеристики, как глубина и высота.</li>
<li>Вы реализовали N-арное дерево и рассмотрели два алгоритма поиска в Деревьях:
<ol class="ordered-list">
<li><strong>Поиск в глубину (DFS) </strong>— рекурсивный алгоритм, который исследует дерево, углубляясь в каждую ветвь до самого конца.</li>
<li><strong>Поиск в ширину (BFS) </strong>— итеративный алгоритм, который посещает узлы по уровням, начиная с корня.</li>
</ol>
</li>
<li>Вы изучили Графы и их основные элементы: узлы (вершины) и ребра (связи между узлами).</li>
<li>Также вы рассмотрели два способа представления графов:
<ol class="ordered-list">
<li><strong>Список смежности</strong>, который хранит список смежных узлов для каждого узла.</li>
<li><strong>Матрица смежности</strong>, где значение в ячейке (i, j) указывает на наличие ребра между узлами i и j.</li>
</ol>
</li>
<li>Далее вы реализовали алгоритм Дейкстры для поиска кратчайших путей в графах и обсудили его ограничения.</li>
</ul>
<p></p>
<div class="h3">Куда двигаться дальше в контексте нелинейных структур</div>
<p></p>
<p>Изучение графов и деревьев — это обширная область, и в этом юните вы рассмотрели только основы.</p>
<p>Например, среди структур Дерево есть множество полезных алгоритмов, таких как:</p>
<ul class="list">
<li>сортировка с помощью двоичного дерева, которая позволяет эффективно упорядочивать данные;</li>
<li>алгоритм А-звезда, помогающий находить наиболее оптимальный путь.</li>
</ul>
<p>Не менее важны и алгоритмы балансировки деревьев, вроде AVL-деревьев или красно-черных деревьев, которые гарантируют эффективность операций поиска, вставки и удаления.</p>
<p>Что касается графов, то здесь вас ждут интересные алгоритмы поиска минимального остовного дерева, такие как:</p>
<ul class="list">
<li>алгоритмы Краскала и Прима, обеспечивающие поиск минимального набора рёбер, соединяющих все вершины графа без циклов;</li>
<li>алгоритмы Беллмана-Форда или Флойда-Уоршелла, которые открывают эффективные способы нахождения самого короткого пути между узлами.</li>
</ul>
<p>Кроме того, важную роль играют алгоритмы потоков в сетях, включая <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0_%E2%80%94_%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0" target="_blank" rel="noopener">алгоритм Форда-Фалкерсона</a>, который помогает решать задачи оптимизации потоков.</p>
<p>Понимание графов и деревьев и умение применять к ним алгоритмы — это ценные навыки для любого разработчика, который хочет создавать эффективные и оптимизированные программы в контексте самых разнообразных областей.</p>
<p></p>
<div class="h3">Задание 4.1</div>
<p></p>
<p>Как мы уже выяснили, текущий алгоритм поиска в ширину файла в N-арном дереве файловой системы не учитывает ситуацию, когда в системе может быть несколько файлов с одним и тем же именем. Для решения этой проблемы вам предлагается модифицировать алгоритм таким образом, чтобы он возвращал все пути к файлам с заданным именем.</p>
<p><strong>Текущий алгоритм:</strong></p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">def</span> <span class="hljs-title function_">breadth_first_search_for_file</span>(<span class="hljs-params">root, target_file</span>):
    <span class="hljs-comment"># Создаем очередь для обхода в ширину</span>
    queue = Queue()
    queue.enqueue((root, <span class="hljs-string">""</span>))

    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> queue.is_empty():
        current_node, current_path = queue.dequeue()

        <span class="hljs-comment"># Обновляем текущий путь, добавляя текущее имя узла</span>
        current_path += current_node.name + <span class="hljs-string">"/"</span>

        <span class="hljs-keyword">if</span> current_node.name == target_file:
            <span class="hljs-comment"># Если текущий узел содержит искомый файл, возвращаем текущий путь</span>
            <span class="hljs-keyword">return</span> current_path

        <span class="hljs-comment"># Добавляем детей текущего узла в очередь для дальнейшего обхода</span>
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> current_node.children:
            queue.enqueue((child, current_path))

    <span class="hljs-comment"># Если файл не найден в дереве, возвращаем None</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></pre>
<p></p>
<details open="">
<summary>Подсказки</summary>
<div class="panel">
<p>Во-первых, вам нужно поменять саму цель алгоритма, и вместо возврата только одного пути к файлу, алгоритм должен возвращать список путей ко всем файлам с указанным именем.</p>
<p>Во-вторых, вам необходимо изменить алгоритм поиска таким образом, чтобы он продолжал добавлять пути к файлам с заданным именем в список вместо возврата первого найденного пути. <strong>Это потребует модификации условия проверки на совпадение и добавления найденного пути к файлу в список.</strong></p>
<p><strong>Пример работы:</strong></p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true">root = TreeNode(<span class="hljs-string">"C:"</span>)

root.add_child(TreeNode(<span class="hljs-string">"Summary.docx"</span>))

documents = TreeNode(<span class="hljs-string">"Documents"</span>)
root.add_child(documents)
documents.add_child(TreeNode(<span class="hljs-string">"Homework.docx"</span>))
documents.add_child(TreeNode(<span class="hljs-string">"Report.docx"</span>))
documents.add_child(TreeNode(<span class="hljs-string">"Summary.docx"</span>))

pictures = TreeNode(<span class="hljs-string">"Pictures"</span>)
root.add_child(pictures)
pictures.add_child(TreeNode(<span class="hljs-string">"Summer.jpg"</span>))
pictures.add_child(TreeNode(<span class="hljs-string">"Winter.jpg"</span>))
pictures.add_child(TreeNode(<span class="hljs-string">"Summary.docx"</span>))

file_paths = breadth_first_search_for_files(root, <span class="hljs-string">'Summary.docx'</span>)
<span class="hljs-keyword">for</span> file_path <span class="hljs-keyword">in</span> file_paths:
    <span class="hljs-built_in">print</span>(file_path[:-<span class="hljs-number">1</span>])
<span class="hljs-comment"># C:/Summary.docx</span>
<span class="hljs-comment"># C:/Documents/Summary.docx</span>
<span class="hljs-comment"># C:/Pictures/Summary.docx</span></pre>
<p><strong>Решение:</strong></p>
<pre class="language-python hljs" contenteditable="false" data-mce-highlighted="true"><span class="hljs-keyword">def</span> <span class="hljs-title function_">breadth_first_search_for_files</span>(<span class="hljs-params">root, target_file</span>):
    <span class="hljs-comment"># Создаем очередь для обхода в ширину</span>
    queue = Queue()
    queue.enqueue((root, <span class="hljs-string">""</span>))

    paths = []  <span class="hljs-comment"># Список для хранения путей к файлам</span>

    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> queue.is_empty():
        current_node, current_path = queue.dequeue()

        <span class="hljs-comment"># Обновляем текущий путь, добавляя текущее имя узла</span>
        current_path += current_node.name + <span class="hljs-string">"/"</span>

        <span class="hljs-keyword">if</span> current_node.name == target_file:
            <span class="hljs-comment"># Если текущий узел содержит искомый файл, добавляем путь в список путей</span>
            paths.append(current_path)

        <span class="hljs-comment"># Добавляем детей текущего узла в очередь для дальнейшего обхода</span>
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> current_node.children:
            queue.enqueue((child, current_path))

    <span class="hljs-keyword">return</span> paths <span class="hljs-keyword">if</span> paths <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></pre>
<p><br><br></p>
<p></p>
<p></p>
</div>
</details>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
</div>
</div>

    </div>
</div>


  
  <script type="text/javascript">
    (function (require) {
        require(['https://lms\u002Dcdn.skillfactory.ru/static/js/dateutil_factory.a28baef97506.js?raw'], function () {
          require(['js/dateutil_factory'], function (DateUtilFactory) {
            
    DateUtilFactory.transform('.localized-datetime');

          });
        });
    }).call(this, require || RequireJS.require);
  </script>


<script>
    function emit_event(message) {
        parent.postMessage(message, '*');
    }
</script>

</div>

      </main>
  </section>
</div>

<link rel="stylesheet" href="./default.min.css">
<script src="./highlight.min.js"></script>
<script type="text/javascript">
  (function() {
    // If this view is rendered in an iframe within the learning microfrontend app
    // it will report the height of its contents to the parent window when the
    // document loads, window resizes, or DOM mutates.
    if (window !== window.parent) {
      document.body.className += ' view-in-mfe';
      var lastHeight = window.offsetHeight;
      var lastWidth = window.offsetWidth;
      var contentElement = document.getElementById('content');

      function dispatchResizeMessage(event) {
        // Note: event is actually an Array of MutationRecord objects
        // when fired from the MutationObserver
        var eventType = event.type || 'mutate';
        var newHeight = contentElement.offsetHeight;
        var newWidth = contentElement.offsetWidth;
        if (eventType !== 'load' && newWidth === lastWidth && newHeight === lastHeight) {
            // Monitor when any anchor tag is clicked, it is checked to make sure
            // it is referencing an element's id or name (not an external website). If
            // the href attribute is an id or name, the location of the selected focus
            // element is sent through its offset attribute. The offset will
            // allow the page to scroll to the location of the focus element so
            // that it is at the top of the page. Unique ids and names are
            // required for proper scrolling.
            $('a').on("click", function(event){
              if ($(this).attr('href')[0] === "#") {
                var targetId = $(this).attr('href');
                var targetName = $(this).attr('href').slice(1);
                // Checks if the target uses an id or name to focus and gets offset.
                var targetOffset = $(targetId).offset() || $(document.getElementsByName(targetName)[0]).offset();
                if (targetOffset) {
                  event.preventDefault();
                  window.parent.postMessage({"offset": targetOffset.top}, document.referrer);
                }
              }
            })
          return;
        }
        // Monitor for messages and checks if the message contains an id. If
        // there is an id, then the location of the selected focus element
        // is sent through its offset attribute. The offset will allow the
        // page to scroll to the location of the focus element so that it is
        // at the top of the page. Unique ids and names are required for
        // proper scrolling.
        window.addEventListener('message', function (event) {
          if (event.data.hashName) {
            var targetId = event.data.hashName;
            var targetName = event.data.hashName.slice(1);
            // Checks if the target uses an id or name to focus and gets offset.
            var targetOffset = $(targetId).offset() || $(document.getElementsByName(targetName)[0]).offset();
            window.parent.postMessage({ 'offset': targetOffset.top }, document.referrer);
          }
        })

        window.parent.postMessage({
            type: 'plugin.resize',
            payload: {
              width: newWidth,
              height: newHeight,
            }
          }, document.referrer
        );

        lastHeight = newHeight;
        lastWidth = newWidth;

          let scrollBeforeFullscreenElement = null;

          function changeHandler() {
              if (!document.fullscreenElement) {
                  if (scrollBeforeFullscreenElement !== null) {
                      window.parent.postMessage(
                          {
                              type: 'iframe.fullscreenExit',
                              payload: {
                                  y: scrollBeforeFullscreenElement.getBoundingClientRect().top + scrollBeforeFullscreenElement.offsetHeight / 2,
                              }
                          }, '*'
                      );
                      scrollBeforeFullscreenElement = null;
                  }
              } else {
                  scrollBeforeFullscreenElement = document.fullscreenElement;
              }
          }

          window.addEventListener('fullscreenchange', changeHandler, true);
          window.addEventListener('webkitfullscreenchange', changeHandler, true);
          window.addEventListener('mozfullscreenchange', changeHandler, true);

        // Within the learning microfrontend the iframe resizes to match the
        // height of this document and it should never scroll. It does scroll
        // ocassionally when javascript is used to focus elements on the page
        // before the parent iframe has been resized to match the content
        // height. This window.scrollTo is an attempt to keep the content at the
        // top of the page. See TNL-7094
        window.scrollTo(0, 0);
      }

      // Create an observer instance linked to the callback function
      const observer = new MutationObserver(dispatchResizeMessage);

      // Start observing the target node for configured mutations
      observer.observe(document.body, { attributes: true, childList: true, subtree: true });

      window.addEventListener('load', dispatchResizeMessage);
      window.addEventListener('resize', dispatchResizeMessage);

      const resizeObserver = new ResizeObserver(dispatchResizeMessage);
      resizeObserver.observe(document.body);
    }
  }());
  document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre').forEach((el) => {
          hljs.highlightElement(el);
      });
  });
</script>

    
</div>





  <script type="text/javascript" src="./jquery.scrollTo.525edcc52fe8.js" async=""></script>
  <script type="text/javascript" src="./jquery.flot.d3d45ff0c6a8.js" async=""></script>

  
    
<script type="text/javascript" src="./lms-courseware.9517dcd2081d.js" charset="utf-8"></script>



    




<script type="text/javascript">
    // Fast Preview was introduced in 2.5. However, it
    // causes undesirable flashing/font size changes when
    // MathJax is used for interactive preview (equation editor).
    // Setting processSectionDelay to 0 (see below) fully eliminates
    // fast preview, but to reduce confusion, we are also setting
    // the option as displayed in the context menu to false.
    // When upgrading to 2.6, check if this variable name changed.
    window.MathJax = {
      menuSettings: {CHTMLpreview: false}
    };
</script>

<script type="text/x-mathjax-config;executed=true">
  MathJax.Hub.Config({
    messageStyle: "none",
    tex2jax: {
      inlineMath: [
        ["\\(","\\)"],
        ['[mathjaxinline]','[/mathjaxinline]']
      ],
      displayMath: [
        ["\\[","\\]"],
        ['[mathjax]','[/mathjax]']
      ]
    }
  });
</script>
<script type="text/x-mathjax-config;executed=true">

  // In order to eliminate all flashing during interactive
  // preview, it is necessary to set processSectionDelay to 0
  // (remove delay between input and output phases). This
  // effectively disables fast preview, regardless of
  // the fast preview setting as shown in the context menu.
  MathJax.Hub.processSectionDelay = 0;

  MathJax.Hub.signal.Interest(function(message) {
    if(message[0] === "End Math") {
        set_mathjax_display_div_settings();
    }
  });
  function set_mathjax_display_div_settings() {
    $('.MathJax_Display').each(function( index ) {
      this.setAttribute('tabindex', '0');
      this.setAttribute('aria-live', 'off');
      this.removeAttribute('role');
      this.removeAttribute('aria-readonly');
    });
  }
</script>

<script type="text/javascript">
    // Activating Mathjax accessibility files
    window.MathJax = {
        menuSettings: {
            collapsible: true,
            autocollapse: false,
            explorer: true
        }
    };
</script>

<!-- This must appear after all mathjax-config blocks, so it is after the imports from the other templates.
     It can't be run through static.url because MathJax uses crazy url introspection to do lazy loading of
     MathJax extension libraries -->
<script type="text/javascript" src="./MathJax.js"></script>


<script src="./HtmlBlockPreview.47dfb3a011d61e073bb9.68644e9f6662.js" type="application/javascript"></script>
<script src="./XModuleShim.b0a0bcfa4bfc116299b0.0021dbb8621f.js" type="application/javascript"></script>
<script src="./VerticalStudentView.218999454019487e3bbe.50411955078b.js" type="application/javascript"></script>







<script type="text/javascript" src="./noreferrer.aa62a3e70ffa.js" charset="utf-8"></script>
<script type="text/javascript" src="./navigation.08930e16ab3d.js" charset="utf-8"></script>
<script type="text/javascript" src="./header.309a1243e175.js"></script>

<script type="text/javascript" src="./jquery_extend_patch.54dddef28d15.js"></script>
<div id="lean_overlay"></div>





<div id="reader-feedback" class="sr" aria-live="polite"></div><div class="tooltip" style="display: none; opacity: 0;"></div></body></html>